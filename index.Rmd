---
title: "Open Case Studies: Exploring CO2 emissions acorss time"
css: style.css
output:
  html_document:
    self_contained: yes
    code_download: yes
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---

<style>
#TOC {
  background: url("https://opencasestudies.github.io/img/logo.jpg");
  background-size: contain;
  padding-top: 240px !important;
  background-repeat: no-repeat;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, comment = NA, echo = TRUE,
                      message = FALSE, warning = FALSE, cache = FALSE,
                      fig.align = "center", out.width = '90%')
library(here)
library(knitr)
```

#### {.outline }
```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "mainplot.png"))
```

####

## {.disclaimer_block}

**Disclaimer**: The purpose of the [Open Case Studies](https://opencasestudies.github.io){target="_blank"} project is **to demonstrate the use of various data science methods, tools, and software in the context of messy, real-world data**. A given case study does not cover all aspects of the research process, is not claiming to be the most appropriate way to analyze a given data set, and should not be used in the context of making policy decisions without external consultation from scientific experts. 

# **Motivation**
*** 

This case study explores how different countries have contributed to Carbon Dioxide (CO2) emissions over time and how CO2 emission rates may relate to increasing global temperatures and increased rates of natural disasters and storms. This report provides a basis for the motivation: https://www.epa.gov/report-environment/greenhouse-gases.


CO2 makes up the largest proportion of greenhouse gas emissions in the United States:


```{r, echo = FALSE, out.width="500px"}
knitr::include_graphics(here::here("img", "emissions.jpg"))
```

A variety of sources and sectors contribute to greenhouse gas emissions, with transportation contributing the most metric tons of CO2:


```{r, echo = FALSE, out.width="600px"}
knitr::include_graphics(here::here("img", "sector.png"))
```

So why should we pay attention to greenhouse gases?

According to the [US Environmental Protection Agency (EPA) Inventory of U.S. Greenhouse Gas Emissions and Sinks 2020 Report](https://www.epa.gov/ghgemissions/inventory-us-greenhouse-gas-emissions-and-sinks): 

> Greenhouse gases absorb infrared radiation, thereby trapping heat in the atmosphere and making the planet warmer. The most important greenhouse gases directly emitted by humans include carbon dioxide (CO2), methane (CH4), nitrous oxide (N2O), and several fluorine-containing halogenated substances. Although CO2, CH4, and N2O occur naturally in the atmosphere, human activities have changed their atmospheric concentrations. From the pre- industrial era (i.e., ending about 1750) to 2018, concentrations of these greenhouse gases have increased globally by 46, 165, and 23 percent, respectively (IPCC 2013; NOAA/ESRL 2019a, 2019b, 2019c). 

* IPCC stands for the Intergovernmental Panel on Climate Change

There are many signs that our planet is experiencing warmer temperatures:

```{r, echo = FALSE, out.width="600px"}
knitr::include_graphics(here::here("img", "warming.png"))
```

The connection between greenhouse gas levels and global temperatures and the influence of increased global temperatures on human health are motivated by these reports:

#### {.reference_block}

Melillo, J.M., T.C. Richmond, and G.W. Yohe (eds.). 2014. Climate change impacts in the United States: The third National Climate Assessment. U.S. Global Change Research Program.  

2020. “Inventory of US Greenhouse Gas Emissions and Sinks: 1990--2018.” EPA 430-R-20-002, Tech. Rep. https://www.epa.gov/ghgemissions/inventory-us-greenhouse-gas-emissions-and-sinks.


####

The National Climate Assessment Report states that:

> Heat-trapping gases already in the atmosphere have committed us to a hotter future with more climate-related impacts over the next few decades. The magnitude of climate change beyond the next few decades depends primarily on the amount of heat-trapping gases that human activities emit globally, now and in the future.

See [here](https://www.epa.gov/report-environment/greenhouse-gases) and [here](https://world101.cfr.org/global-era-issues/climate-change/climate-change-adaptations) for more information.

# **Main Questions**
*** 

#### {.main_question_block}
<b><u> Our main question: </u></b>

1) How have global CO2 emission rates changed over time? In particular for the US, and how does the US compare to other countries? 
2) Are US CO2 emissions, global temperatures, and US storm rates associated? 

####

# **Learning Objectives** 
*** 

In this case study, we will explore CO2 emission data from around the world. We will also focus on the US specifically to evaluate patterns of temperatures and storm activity. This case study will particularly focus on how to use different datasets that span different ranges of time, as well as how to create visualizations of patterns over time. We will especially focus on using packages and functions from the [`Tidyverse`](https://www.tidyverse.org/){target="_blank"}, such as `dplyr`, `tidyr`, `ggplot2`and `gganimate`. The tidyverse is a library of packages created by RStudio. While some students may be familiar with previous R programming packages, these packages make data science in R especially efficient.


*** 


We will begin by loading the packages that we will need:

```{r}
library(here)
library(readxl)
library(readr)
library(dplyr)
library(magrittr)
library(tidyverse)
library(ggplot2)
library(gganimate)
library(directlabels)
library(ggrepel)
library(RColorBrewer)
library(patchwork)
```


 Package   | Use                                                                         
---------- |-------------
[here](https://github.com/jennybc/here_here){target="_blank"}       | to easily load and save data
[readxl](https://readxl.tidyverse.org/){target="_blank"}  | to import the excel file data
[readr](https://readr.tidyverse.org/){target="_blank"}  | to import the csv file data
[dplyr](https://dplyr.tidyverse.org/){target="_blank"}  |  to view and wrangle the data
[magrittr](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html){target="_blank"}  |  to use and reassign data objects using the `%<>%`pipe operator
[tidyverse](https://www.tidyverse.org/packages/){target="_blank"}  | to wrangle the data and create ggplot2 plots
[ggplot2](https://ggplot2.tidyverse.org/){target="_blank"} | to make visualizations
[directlabels](http://directlabels.r-forge.r-project.org/docs/index.html){target="_blank"} | to add labels to plots easily
[ggrepel](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html){target="_blank"} | to add labels that don't overlap to plots
[gganimate](https://gganimate.com/){target="_blank"}  | to make the plots interactive
[RColorBrewer](https://cran.r-project.org/web/packages/RColorBrewer/index.html){target="_blank"}  | to have greater control over the color in our plots
[patchwork](https://github.com/thomasp85/patchwork){target="_blank"}  | to combine plots
The first time we use a function, we will use the `::` to indicate which package we are using. Unless we have overlapping function names, this is not necessary, but we will include it here to be informative about where the functions we will use come from.


# **Context**
*** 

Greenhouse gas emissions are due to both natural processes and anthropogenic (human-derived) activities. 

These emissions are one of the contributing factors to rising global temperatures, which can have a great influence on [public health](https://www.epa.gov/climate-indicators/understanding-connections-between-climate-change-and-human-health){target="_blank"}  as illustrated in the following image:

```{r, echo = FALSE, out.width="800px"}
knitr::include_graphics(here::here("img", "health.png"))
```

> Gases in the atmosphere can contribute to climate change both directly and indirectly. Direct effects occur when the gas itself absorbs radiation. Indirect radiative forcing occurs when chemical transformations of the substance produce other greenhouse gases, when a gas influences the atmospheric lifetimes of other gases, and/or when a gas affects atmospheric processes that alter the radiative balance of the earth (e.g., affect cloud formation or albedo). The IPCC developed the Global Warming Potential (GWP) concept to compare the ability of a greenhouse gas to trap heat in the atmosphere relative to another gas.
The GWP of a greenhouse gas is defined as the ratio of the accumulated radiative forcing within a specific time horizon caused by emitting 1 kilogram of the gas, relative to that of the reference gas CO2 (IPCC 2013). Therefore GWP-weighted emissions are provided in million metric tons of CO2 equivalent (MMT CO2 Eq.)


 CO2 is actually the least capable of the greenhouse gases for trapping heat:

```{r, echo = FALSE, out.width="800px"}
knitr::include_graphics(here::here("img", "GWP.png"))
```

However, because CO2 is so much more abundant and stays in the atmosphere so much longer than other greenhouse gases, it has been the largest contributor to global warming.

See [here](https://www.ucsusa.org/resources/why-does-co2-get-more-attention-other-gases#:~:text=CO2%20sticks%20around,oxide%20(N2O){target="_blank"}.)
for more details.


Furthermore, sizing CO2 levels also influence ocean acidity:

```{r, echo = FALSE, out.width="500px"}
knitr::include_graphics(here::here("img", "oceans.png"))
```

This makes it difficult for organisms to maintain their shells or skeletons that are made of calcium carbonate, thus making it more difficult for these organisms to survive and impacting their role in the ecosystem and food chain. 


Furthermore, greenhouse gas emissions are believed to influence storm rates. 

Indeed events with high levels of precipitation which can induce flooding and property damage are generally increasing around the country:

```{r, echo = FALSE, out.width="500px"}
knitr::include_graphics(here::here("img", "storms.png"))
```


# **Limitations**
*** 

There are some important considerations regarding this data analysis to keep in mind: 

1) The datasets included only include countries and years in which countries were reporting such information to the agencies that collected the data. Thus the data is incomplete. For example while we have a fairly good sense of CO2 emissions globally for later years, additional emissions were also produced by countries that are not included in the data.

2) [Correlation or association does not imply causation](https://dfrieds.com/math/correlation-does-not-imply-causation.html){target="_blank"}. We will be showing how different datasets show similar trends across time. This does not imply that one caused the other. However, in the case of some of the data we will show, there is additional scientific evidence to suggest that for example, increased CO2 emissions may cause increased temperatures or increased rates of disasters. However, simply showing a similar trend over time does not in itself prove that two variables are causally related. As you can see from this plot, often data may show a similar pattern over time by random chance.  See this [website](https://www.tylervigen.com/spurious-correlations){target="_blank"} for more examples.

```{r, echo = FALSE, out.width="500px"}
knitr::include_graphics(here::here("img", "causation.png"))
```




# **What are the data?**
*** 

In this case study we will be using data related to CO2 emissions, as well as other data that may influence, be influenced or relate to CO2 emissions. Most of our data was obtained from [Gapminder](https://www.gapminder.org/data/){target="_blank"}, which is a unique nonprofit that provides a variety of data for free.

In their words, Gapminder is...

> Gapminder is an independent Swedish foundation with no political, religious or economic affiliations. Gapminder is a fact tank, not a think tank. Gapminder fights devastating misconceptions about global development. Gapminder produces free teaching resources making the world understandable based on reliable statistics. Gapminder promotes a fact-based worldview everyone can understand.  Gapminder collaborates with universities, UN, public agencies and non-governmental organizations. All Gapminder activities are governed by the board. We do not award grants. Gapminder Foundation is registered at Stockholm County Administration Board. Our constitution can be found [here](https://www.gapminder.org/about-gapminder/constitution/).

The data that we will be using from Gapminder was obtained from the [World Bank](https://www.worldbank.org/en/what-we-do){target="_blank"}.


In addition we will use some data that is specific to the United States from the [National Oceanic and Atmospheric Administration (NOAA)] (https://www.noaa.gov/), which is an agency that collects weather and climate data.


Data   | Time span | Source  | Orginal Source   | Description | Citation                                                                    
---------- |-------------|-------------|-------------|--------|-------
**CO2 emissions**  |1751 to 2014 | [Gapminder](https://www.gapminder.org/data/){target="_blank"}  | [Carbon Dioxid Information Analysis Center (CDIAC)](https://cdiac.ess-dive.lbl.gov/){target="_blank"}  |  CO2 emissions in tonnes or metric tons (equivalent to approximately 2,204.6 pounds) per person by country| NA
**GDP per capita, percent yearly growth** | 1801 to 2019| [Gapminder](https://www.gapminder.org/data/){target="_blank"}  | [World Bank](https://data.worldbank.org/indicator/NY.GDP.PCAP.KD.ZG){target="_blank"}  |  [Growth Domestic Product](https://www.investopedia.com/terms/g/gdp.asp#:~:text=Gross%20Domestic%20Product%20(GDP)%20is%20the%20monetary%20value%20of%20all,expenditures%2C%20production%2C%20or%20incomes.){target="_blank"}  (which is an overall measure of the health of nation's economy) per person by country| NA
**Energy use per person** |1960 to 2015 | [Gapminder](https://www.gapminder.org/data/){target="_blank"}  | [World Bank](https://data.worldbank.org/indicator/EG.USE.PCAP.KG.OE){target="_blank"}  |  Use of primary energy before transformation to other end-use fuels, by country | NA
**Crude Mortality Rate** |1960 to 2018 | [World Bank](https://data.worldbank.org/indicator/SP.DYN.CDRT.IN){target="_blank"}  | [World Bank](https://data.worldbank.org/indicator/SP.DYN.CDRT.IN){target="_blank"} |  Death rate per 1,000 people by country | NA 
**US Natural Disasters** | 1980 to 2019 | [The National Oceanic and Atmospheric Administration (NOAA)](https://www.ncdc.noaa.gov/billions/time-series){target="_blank"}| [The National Oceanic and Atmospheric Administration (NOAA) ](https://www.ncdc.noaa.gov/billions/time-series){target="_blank"}|  US data about: <br> -- Droughts <br> -- Floods <br> -- Freezes <br> -- Severe Storms <br> -- Tropical Cyclones <br> -- Wildfires<br> -- Winter Storms | NOAA National Centers for Environmental Information (NCEI) U.S. Billion-Dollar Weather and Climate Disasters (2020). https://www.ncdc.noaa.gov/billions/, DOI: 10.25921/stkw-7w73
**Temperature**  | 1895 to 2019|  [The National Oceanic and Atmospheric Administration (NOAA)](https://www.ncdc.noaa.gov/cag/national/time-series){target="_blank"}  | [The National Oceanic and Atmospheric Administration (NOAA)](https://www.ncdc.noaa.gov/cag/national/time-series){target="_blank"} | US National yearly average temperature (in Fahrenheit) from 1895 to 2019 | NOAA National Centers for Environmental information, Climate at a Glance: National Time Series, published June 2020, retrieved on June 26, 2020 from https://www.ncdc.noaa.gov/cag/


To obtain the temperature data, annual average temperatures were selected as shown in this image:
```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "temp.png"))
```


Importantly, notice that the data we would like to use span different time periods:

Data   | Time span                                                                     
---------- |-------------
**CO2 emissions**  |1751 to 2014 
**GDP per capita, yearly growth** | 1801 to 2019
**Energy use per person** |1960 to 2015 
**Crude Mortality Rate** |1960 to 2018 
**US Natural Disasters** | 1980 to 2019 
**Temperature**  | 1895 to 2019




# **Data Import**
*** 

To read in the files that were downloaded from the various sources as indicated in the table above, we will use the `read_xlsx()` and `read_xls()` functions of the `readxl` package to import the data from the .xlsx and .xls files respectively and we will use the `read_csv` function of the `readr` package to import the data from the csv files.

```{r}
# xlsx files:
CO2_emissions <- readxl::read_xlsx(here("docs/yearly_co2_emissions_1000_tonnes.xlsx"))
gdp_growth <- readxl::read_xlsx(here("docs/gdp_per_capita_yearly_growth.xlsx"))
energy_use <- readxl::read_xlsx(here("docs/energy_use_per_person.xlsx"))

# xls file:
mortality <- readxl::read_xls(here("docs/API_SP.DYN.CDRT.IN_DS2_en_excel_v2_804384.xls"))
```

For our csv data files, there are some lines that we would like to not import - in fact, we will get an error if we try to import them because our table structure will be as r expects. We can do so using the `skip =` argument of the `read_csv()` function. 

Here you can see that the first two rows of the data about US Disasters doesn't have the same number of columns as the subsequent rows. So we want to skip these first two lines, we will use `skip = 2` for this.

```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "Disasters.png"))
```
Now looking at the temperature data, we can see that  the first four lines do not have the same number of columns as the subsequent lines. We will skip importing all 4 lines by using `skip = 4`. We can also specify that `NA` values are encoded as `"-99"`. This will replace all instances of `"-99"` with `NA`. We can do this using the `na = ` argument of the `read_csv()` function. We will do so as: `na = "-99"`. The "-99" needs to be in quotation marks because this argument expects characters.

```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "tempdata.png"))
```

```{r}
#csv files:
us_disaster <- readr::read_csv(here("docs/time-series-US.csv"), skip = 2)
us_temperature <- readr::read_csv(here("docs/temperature.csv"), skip = 4, na ="-99")
mortality2 <-readr::read_csv(here("docs/mortality.csv"), skip = 5)
```

Great! now we have imported all of the data that we will need.


# **Data Wrangling**
*** 

Now we will take a look at our data and wrangle it until it is easy to use to allow us to evaluate how CO2 emissions have changed over time and how emissions may relate to energy use, mortality, GDP etc. 

## Yearly CO~2~ Emissions

First let's take a look at the CO2 data. We can use the base `slice_head()` function of the `dplyr` package to see just the first rows of our data. We can specify how many rows we would like to see by using the `n =` argument. It is also useful to use the `slice_sample()` function to look at a selection of random rows.

We will use the `%>%` pipe which can be used to define the input for later sequential steps. This will make more sense when we have multiple sequential steps using the same data object. To use the pipe notation we need to install and load  the `dplyr` package.

```{r}
CO2_emissions %>%
  slice_head(n = 6)

CO2_emissions %>%
  slice_sample(n = 10)
```

OK, we can see that our country data makes of the rows and the yearly data makes up the columns. We also see that we have a lot of `NA` values.


We can also use the `glimpse()` function of the `dplyr` package to view our data. This allows us to see more of our data at once. We will see a tiny bit of each variable/column. To do so our data will be displayed with the column names listed on the right.

#### {.scrollable }
```{r}
# Scroll through the output!
CO2_emissions %>%
dplyr::glimpse()
```
####



We can see that we have a large [tibble](https://tibble.tidyverse.org/). A tibble is the tidyverse version of a data frame. It is essentially a table with variable information arranged as columns, and individual observations arranged as rows. We can see that the tibble gives us information about the class of each variable.  For example the `country` variable is made up of character (abbreviated as chr) values. We see that we have 265 different country variables and CO2 emission values for 192 different years (from 1751 to 2014). Recall that the values are emissions in metric tons also called tonnes. We can see that there are fewer `NA` values for later years.

Now we will modify this data to make it more usable for making visualizations. One thing we will use is the `%<>%` operator which is from the `magrittr` package. This allows us to use our `CO2_emissions` data and reassign it to a modified version at the same time. 

We will use the `pivot_longer()` function of the `dplyr` package to convert our data into what is called long format. This means that we will have more rows and fewer columns than our current format. This is done by collapsing multiple variables into fewer variables.

We want to collapse all of the values for the emission data across the different individual year variables into one new emission variable and we will identify what year they are from using a new `Year` variable.

```{r}
CO2_emissions  %<>%
  pivot_longer(cols = -country, names_to = "Year", values_to = "Emissions")

CO2_emissions %>%
  slice_sample(n = 6)
```

We also want to rename the `country` variable to be capitalized.  We can use the `rename()` function of the `dplyr` package to rename this variable. When renaming variables the new name is listed first before the `=`. We will also modify the `Emissions` data by dividing it by 1000 to make the numbers smaller. To do this we will use the `mutate()` function, which is also part of the `dplyr()` package. This function allows us to create and modify variables. You may also note that the `Year` variable is currently of class type character. We would like to change it to be numeric. This can also be accomplished using the `mutate()` function.

```{r}
  
 CO2_emissions  %<>% 
   dplyr::rename(Country=country) %>%
#   dplyr::mutate(Emissions = Emissions/1000, 
         dplyr::mutate(Year = as.numeric(Year),
          Label = "CO2 Emissions (Metric Tons)")
     #rename(`CO2 Emissions (Mg)`= Emissions)

```

Now let's take a look to see how our data has changed:

```{r}

CO2_emissions %>%
slice_sample(n = 6)

```
Great, we can see that now the `Year` variable is of class double (abbreviated `dbl`), which is a numeric class.


Now let's take a look at the `Country` variable just to check if there is anything unexpected. We will use the `distinct()` function of the `dplyr` package to view the unique values only.

#### {.scrollable }
```{r}
#Scroll through the output!
CO2_emissions %>%
       distinct(Country)

```
####

These all look as expected!


## Yearly Growth in GDP per Capita

```{r}
gdp_growth %>%
  slice_head(n = 6)
```

```{r}
names(gdp_growth)
```

#### {.scrollable}
```{r}
# Scroll through the output!
gdp_growth %>%
glimpse()
```
####

Again, we will use the `pivot_longer()` to transform the data to long format. We will also again change the `country` variable to be `Country` by using the `rename()` function , and we will make the `Year` variable numeric using the `mutate()` function. 



```{r}
gdp_growth %<>%
  pivot_longer(cols = -country, 
               names_to = "Year", 
               values_to = "gdp_growth") %>%
  rename(Country=country) %>%
  mutate(Year = as.numeric(Year),
         Label = "GDP Growth/Capita (%)") %>%
  rename(GDP = gdp_growth)
```

Now let's see how this data has changed:

```{r}
gdp_growth %>%
  slice_head(n = 6)

gdp_growth %>%
  count(Year)
```


Again let's check that the `Country` variable only contains values we would expect.

#### {.scrollable }
```{r}
#Scroll through the output!
gdp_growth %>%
       distinct(Country)

```
####

Also looks good!

## Energy Use per Person

Now let's take a look at the energy use per person data:

```{r}
energy_use %>%
  slice_head(n = 6)
```

#### {.scrollable}
```{r}
energy_use %>%
  glimpse()
```
####

To wrangle the `energy_use` data, we will again convert the data to long format, rename some variables, and mutate the `Year` data to be numeric.

```{r}
energy_use %<>%
  pivot_longer(cols = -country, 
           names_to = "Year", 
          values_to = "energy_use") %>%
  rename(Country = country) %>%
  mutate(Year = as.numeric(Year),
         Label = "Energy Use (kg, oil-eq./capita)") %>%
  rename(Energy = energy_use)

```


```{r}
energy_use %>%
slice_sample(n = 10)
```

Now we will check the `Country` variable:

#### {.scrollable }
```{r}
#Scroll through the output!
energy_use %>%
       distinct(Country)

```
####


Looks good!


## Crude Mortality Rate

```{r}
mortality %>%
  slice_head(n = 6)
```


We can see that there are a couple of empty rows which indicate when the data was updated.
We can also see that the columns really start at the 3rd row. So first we will replace the column names with the 3rd row. Then we will remove the first 3 rows.

```{r}
colnames(mortality)
colnames(mortality) <- mortality[3,]
colnames(mortality)
mortality <- mortality[-c(1:3),]
```



#### {.scrollable}
```{r}
mortality %>%
  glimpse()

```
####


That is looking better! However, we also want to remove some variables like: `Country Code`, `Indicator Name`, and `Indicator Code`. We can do that using the `select()` function of the `dplyr` package. We can use the minus sign `-` to indicate what variables we don't want to keep. Otherwise, we will perform similar modifications as we performed on the other datasets. Note that these variable names need quotation marks around them because they have spaces. 

```{r}
mortality %<>%
  select(-"Country Code",
         -"Indicator Name",
         -"Indicator Code") %>%
  rename(Country = "Country Name") %>%
  pivot_longer(cols = -Country, 
               names_to = "Year", 
               values_to = "Deaths") %>%
  mutate(Year = as.numeric(Year),
       Deaths = as.numeric(Deaths),
       Label = "Deaths/1000 People")

```

```{r}
mortality %>%
  slice_head(n = 6)
```

Let's check the `Country` variable:

#### {.scrollable }
```{r}
#Scroll through the output!
mortality %>%
       distinct(Country)

```
####

OK, in this case it looks like there are some regions included as well, like:

"East Asia & Pacific (excluding high income)", "Early-demographic dividend", "East Asia & Pacific", "Europe & Central Asia (excluding high income)", "Europe & Central Asia", "Euro area", "Fragile and conflict affected situations", "European Union", "Heavily indebted poor countries (HIPC)", "IBRD only", "IDA & IBRD total", "IDA total", "IDA blend", "IDA only", "Not classified", "Latin America & Caribbean (excluding high income)", "Latin America & Caribbean", "Least developed countries: UN classification","Low income"," Lower middle income", "Low & middle income", "Late-demographic dividend", "Middle East & North Africa", "Middle income", "Middle East & North Africa (excluding high income)", "North America", "OECD members", "Other small states", "Pre-demographic dividend", "West Bank and Gaza", "Pacific island small states", "Post-demographic dividend", "French Polynesia", "South Asia", 
"Sub-Saharan Africa (excluding high income)", "Sub-Saharan Africa", "East Asia & Pacific (IDA & IBRD countries)", "Europe & Central Asia (IDA & IBRD countries)", "Latin America & the Caribbean (IDA & IBRD countries)", "Middle East & North Africa (IDA & IBRD countries)", "South Asia (IDA & IBRD)", "Sub-Saharan Africa (IDA & IBRD countries)", "Upper middle income". 


Let's remove these regions:
```{r}
mortality %<>% 
filter(!Country %in% c("East Asia & Pacific (excluding high income)", "Early-demographic dividend", "East Asia & Pacific", "Europe & Central Asia (excluding high income)", "Europe & Central Asia", "Euro area", "Fragile and conflict affected situations", "European Union", "Heavily indebted poor countries (HIPC)", "IBRD only", "IDA & IBRD total", "IDA total", "IDA blend", "IDA only", "Not classified", "Latin America & Caribbean (excluding high income)", "Latin America & Caribbean", "Least developed countries: UN classification", "Low income"," Lower middle income", "Low & middle income", "Late-demographic dividend", "Middle East & North Africa", "Middle income", "Middle East & North Africa (excluding high income)", "North America", "OECD members", "Other small states", "Pre-demographic dividend", "West Bank and Gaza", "Pacific island small states", "Post-demographic dividend", "French Polynesia", "South Asia", 
"Sub-Saharan Africa (excluding high income)", "Sub-Saharan Africa", "East Asia & Pacific (IDA & IBRD countries)", "Europe & Central Asia (IDA & IBRD countries)", "Latin America & the Caribbean (IDA & IBRD countries)", "Middle East & North Africa (IDA & IBRD countries)", "South Asia (IDA & IBRD)", "Sub-Saharan Africa (IDA & IBRD countries)", "Upper middle income"))  

```




## US Specific Data

Now we will take a look at the US data about disasters and temperature.

### Disasters

```{r}
us_disaster 
```

We are specifically interested in the `Year` and  the variables that contain the word `"Count"` so we will select them using the `select()` and `contains()` functions in the `dplyr` package. Since we are selecting for variables with the word `"Count"` we need to use quotation marks around it. Selecting for the variable `year` does not require this as that is actually the name of one of the existing variables.


```{r}
us_disaster %<>%
           select(Year, contains("Count"))

us_disaster %>%
  slice_head(n = 6)
```

Now we want to create a new variable that will be the sum of all the different types of disasters for each year. 

We can create this new variable using the `mutate()` function of `dplyr` and we will use the base `rowSums()` function to perform the calculation. We don't want to include the `Year` variable in our sum, so we can exclude it using the `select`function within the `rowSums()` function. However, to do so we need to indicate that we are using the data that we already used as input to our `mutate()` and `rowSums()` functions. We can do so by using a `.`. 


```{r}
us_disaster %<>%
  mutate(`Disasters` = rowSums(select(., -Year))) 

us_disaster %>%
  glimpse()
```

Great, now we are going to remove some of these variables and just keep or select using the `select()` function the variables we are interested in. We will keep the `Flooding Count` because as you may recall from earlier in this case study, events of extreme precipitation levels appear to be associated with global warming. We will use this as a proxy for that.

We are also going to add a new variable called `Country` to indicate that this data is from the United States. This will create a new variable where every value is `United States`.
```{r}
us_disaster %<>%
  dplyr::select(Year,
                Disasters) %>%
  mutate(Country = "United States") %>%
  pivot_longer(cols = c(- Country, - Year),
           names_to = "Indicator",
          values_to = "Value") %>%
  mutate(Label = "Number of Disasters")

us_disaster %>%
  slice_head(n = 6)
```



### Temperature

```{r}
us_temperature %>%
  slice_head(n = 6)
```
OK, so we want to remove the `Anomaly` variable which is an indicator of how different the national average temperature for that year was from the average temperature from 1901-2000 which was 52.02&deg;F. 

We also want to change the date values, which are currently listed as the year followed by the number 12. To do so we want to just keep the first 4 characters in the `Date` variable string values. We can use the `str_sub()` function of the `stringr` package to do this. We just need to indicate the start and stop characters. In this case the start would be 1 and the 4th character would be where we want to stop, so we would use `start = 1, stop = 4`. Again we will create a `Country` variable. We will also change the name of the `Date` variable to `Year` so that it will be consistent with our other datasets. Furthermore, we also what it to be numeric. We can accomplish both renaming and changing to numeric by using the `mutate()` function. We can then remove the `Date` variable and also order the columns just like the other us data using the `select()` function.

```{r}
us_temperature %<>%
  dplyr::select(-Anomaly) %>%
  mutate(Date = str_sub(Date, start = 1, end = 4))%>%
  rename() %>%
  mutate(Year = as.numeric(Date), 
      Country = "United States",
    Indicator = "Temperature",
        Label = "Temperature (Fahrenheit)") %>%
  select(Year, Country, Indicator, Value, Label)

us_temperature %>%
  slice_head(n = 6)
```


## Joining data

Now we would like to join the different datasets together into one tibble. To do so it is often necessary to have at least one column or variable with the same name to be used as a key for putting your data together. To put all of our data together there are several `*_join()` functions available in the `dplyr` package. 


```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "join.png"))
```

We will use the `full_join()` function as we have different time spans for each dataset and we would like to retain as much data as possible. The`full_join()` function will simply create `NA` values for any of the years that are not in one of the data sets. We can check by using the base `summary()` function. This will also allow us to check that there are column names that are consistent in each dataset that we wish to combine.

```{r}
summary(CO2_emissions)
summary(gdp_growth)
summary(energy_use)
summary(mortality)

```

Indeed, `Country`, and `Year` variables are present in all of the datasets. We can see that the minimum and maximum year is different for nearly all the datasets.

We need to specify what columns/variables we will be joining by using the `by =` argument in the `full_join()` function.

```{r}

data_wide <- CO2_emissions %>%
  full_join(gdp_growth, by = c("Country", "Year", "Label")) %>%
  full_join(energy_use, by = c("Country", "Year", "Label")) %>%
  full_join(mortality, by = c("Country", "Year", "Label"))

data_wide %>%
  slice_sample(n = 6)

```

We can also do the same thing using by using the`reduce()` function of the `purrr` package. This is a good option if you have many dasasets to combine.


```{r}
data_wide <- list(CO2_emissions, 
                gdp_growth, 
                energy_use, 
                mortality) %>% 
  reduce(full_join, by = c("Country", "Year", "Label"))

data_wide %>%
  slice_head(n = 6)
```

```{r}
data_wide %>%
  glimpse()
```

Nice, looks good!

We will also make a long version of this data, where we will create an new variable called `Indicator` that will indicate what dataset the data came from and we will collapse the values from the columns called ` Emissions` (`CO2 Emissions (Mg)`), `GDP`(`GDP Growth/Capita (%)`), `Energy`(`Energy Use (kg, oil-eq./capita)`), and `Deaths` (`Deaths/1000 People`). 


```{r}
data_long <- data_wide %>%
  pivot_longer(cols = c(-Country, -Year, -Label), 
               names_to = "Indicator", 
               values_to = "Value")
data_long %>%
  slice_sample(n = 6)
```



We will now combine this data with the US data about disasters and temperatures.

We will now use the `bind_rows()` function which will just append the `us_temperature` data and the `us_disaster` data after the `data_long` data. 


```{r}
us_disaster %>%
  slice_head(n = 6)     
us_temperature %>%
  slice_head(n = 6)    

data_long <-list(data_long, 
               us_disaster,
               us_temperature) %>%
  bind_rows()
data_long$Country <- as.factor(data_long$Country)
```

We can check the top and bottom of the new `data_long` tibble to see that our `us_temperature` data is at the bottom. To see the end of our tibble we can use `slice_tail()` function of the `dplyr` package.

```{r}
data_long %>%
  slice_head(n = 6)

data_long %>%
  slice_tail(n = 6)

data_long %>%
  slice_sample(n = 10)
```


<details> <summary> Click here for details about the difference between `full_join()` and `bind_rows()` </summary>

The difference between this function and the `full_join()` function is that the `bind_rows()` function will essentially just append each dataset to each other, whereas the `full_join()` function collapses data that is comparable. Here you will see an example of what the data would have been like for `data_wide` if we had made it using `bind_rows()` and if `full_join()` had been used but was not joined by the `Label` variable. Since the `Label` variable has unique values for each type of `Indicator`, this causes the `full_join()` result to be the same as `bind_rows()`. We will specifically look at the values for China in the year of 1980.

```{r}
data_wide_br <- list(CO2_emissions, 
                gdp_growth, 
                energy_use, 
                mortality) %>% 
  bind_rows()


data_wide_fj <- list(CO2_emissions, 
                gdp_growth, 
                energy_use, 
                mortality) %>% 
  reduce(full_join, by = c("Country", "Year"))

data_wide_fj_label <- list(CO2_emissions, 
                gdp_growth, 
                energy_use, 
                mortality) %>% 
  reduce(full_join, by = c("Country", "Year", "Label"))


dim(data_wide_fj)
dim(data_wide_br)

identical(data_wide_fj_label, data_wide_br)

data_wide_fj %>%
  filter(Country == "China", Year == "1980")

data_wide_br %>%
  filter(Country == "China", Year == "1980")

data_wide_fj_label %>%
  filter(Country == "China", Year == "1980")
```
</detials>



We will also create a new variable called `Region` that will indicate if the data is about the United States or a different country based on the values in the `Country` variable. We will use the `case_when()` function of the `dplyr` package to do this. If the `Country` variable is equal to `"United States"` the value for the new variable will also be "United States", where as if the `Country` variable is not equal to `"United States"` but is some other character string value, such as `"Afghanistan"`, then the value for the new variable will be `"Rest of the World"`.
The new values for the new variable `Region` are indicated after the specific conditional statements by using the `~` symbol. 


```{r}
 data_long %<>%
  mutate(Region = case_when(Country == "United States" ~ "United States",
                            Country != "United States" ~ "Rest of the World"))


data_long %>%
  slice_head(n = 6)
```

To remove entries for countries with NA values we can use the `drop_na()` function of the `tidyr` package to drop all years with missing data.

```{r}
data_long_with_miss <- data_long %>%
  arrange(Country)

data_long %<>%
  drop_na() %>%
  arrange(Country)

```

You can see that by removing the NA values the data for Afghanistan starts at 1949 instead of 1751.

```{r}

data_long %>%
  slice_head(n = 6)

```

# **Data Exploration**
*** 
Now we will create some simple plots to examine the data.

We can check the time span of this data by referring back to the  [**What are the data?**] section. To make these plots we will use the `ggplot2` package. The first step in creating a plot is to define what data we intend to use and what data will be plotted on the x-axis, the y-axis, and if any data will be used to determine the color or the fill (also color of plots that have something to fill like a bar plot) or group. All of these are defined using the `aes()` argument, which is short for aesthetic mappings.

First we will take a look at the CO2 emission data.

## CO2 Emissions (1751-2014)

We first need to give the correct data input. We will filter our data to only include the CO2 emissions data by using the `filter()` function of the `dplyr` package. To use this function we need to specify what value we want for a given variable. In this case we want all rows where the `Indicator` variable is equal to the word `Emissions`. Notice that this needs to be in quotes, while the variable name does not.

Then we use the `aes()` argument of the `ggplot()` function to define that our x-axis will be the `Year` variable, the y-axis will be the emission `Value` variable, and that our data should be grouped or separated by the `Country` variable. If we were to stop there we would get a blank plot, as you can see below. We need to add another layer to define how we want the plot to look. We do so by using the `+` sign in between each command. 


```{r}
data_long %>%
  filter(Indicator == "Emissions") %>%
  ggplot(aes(x = Year, y = Value, group = Country))

```
We will use the `geom_line()` function because we would like to create a line plot. There are many `geom_*` functions to choose from that create many different types of plots.

Type `geom` into the RStudio console and you will see many options to scroll through.

```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "geom_.png"))
```
Since we have many overlapping lines, we will make our lines slightly transparent by using the `alpha` argument. This takes values from 0 to 1, where 0 is completely transparent and 1 is completely opaque. We will also add labels using the `labs()` function. Again, notice that a plus sign is used between each layer that we add to the plot. To make CO2 appear with a subscript we can use `~CO[2]~`. We will also use the function `theme_linedraw()` of `ggplot2` to change the general appearance of the plot. 

Type `theme_` in the RStudio console to see the various plot theme options available.

```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "themes.png"))
```

We will also use the `theme()` function to change the font size of the x-axis, y-axis, axis titles, and the caption as shown below. To know what to call each element of the plot in this function to change the size type `?theme()` in the console. You will see a very large list that includes other plot aspects like the background and the legend. This function can be used to modify your plot to your specifications. We will also use it to remove the legend title by using `element_blank()`. In this case, we are also saving the plot to an object called `co2plot`. To show the plot we simply type the name of the object.

```{r}
co2plot <-data_long %>%
  filter(Indicator == "Emissions") %>%
  ggplot(aes(x = Year, y = Value, group = Country))+
  geom_line(alpha = 0.4) + 
  labs(title = "Country" ~CO[2]~ "Emissions per Year, 1751-2014",
     caption = "Limited to reporting countries",
           y = "Emissions (Metric Tons)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       legend.title = element_blank())

co2plot
```

Great! We've created our first plot. We can see that many countries show a dramatic increase in emissions over time with a handful of countries with particularly high levels. What about the United States? Which line indicates the emissions in the US? We can add another layer on top of our first plot to add a red line just for the US data. To do this we need to indicate what data we would like to plot, so we need to filter for just the US data and then we need to indicate that it will be colored by Country, even though in this case we only have one line to color. The default color would be a salmon pink color, but we would like red. So we will use the `scale_color_manual()` function to manually choose the color that we want by using `scale_colour_manual(values = c("red"))`. Notice how the color name needs to be in quotes and that the argument `values =` is used to specify what color values to use.

We can add this line to the plot in two ways. The first way is to add the code for this layer to the original code that we used to create the `co2plot` or the second way is to simply add to that plot object by using the `+`.

```{r}
data_long %>%
  filter(Indicator == "Emissions") %>%
  ggplot(aes(x = Year, y = Value, group = Country))+
  geom_line(alpha = 0.4) + 
  labs(title = "Country" ~CO[2]~ "Emissions per Year, 1751-2014",
     caption = "Limited to reporting countries",
           y = "Emissions (Metric Tons)") +
  geom_line(data = data_long %>%
  filter(Indicator == "Emissions",
         Country == "United States"), aes(x=Year, y=Value, color = Country)) +
  scale_colour_manual(values=c("red")) +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       legend.title = element_blank())

co2plot + geom_line(data = data_long %>%
  filter(Indicator == "Emissions",
         Country == "United States"), aes(x=Year, y=Value, color = Country)) +
  scale_colour_manual(values=c("red"))
```

It looks like the US has long been the largest CO2 emission producing country until recently, when the US was surpassed by another country. 

Let's figure out which country, by seeing what the top 10 emission producing countries were in 2014. We can do so by filtering the data for 2014, which was the final year of the data. Then we can make a rank variable based on the `Value` variable for the amount of emissions produced. There are many functions in the `dplyr` package for ranking values that are based on the [SQL](https://en.wikipedia.org/wiki/SQL){target="_blank"} [rank functions](https://www.sqlshack.com/overview-of-sql-rank-functions/){target="_blank"}. SQL is another programming language for managing large amounts of data. The difference in the rank functions mostly has to do with how to deal with ties in the data.  We will use `dense_rank()`, as we do not want gaps between ranks.

```{r, echo = FALSE, out.width = "600 px"}
knitr::include_graphics(here::here("img", "rank.png"))
```

We want to do this in descending order because we want to rank by largest to smallest, so we will use the `desc()` function of the `dplyr` package. Then we will arrange the output by rank using the `arrange()` function of the `dplyr` package. 

```{r}

top_10_count <-data_long %>%
    filter(Indicator=="Emissions") %>%
    filter(Year==2014) %>%
    mutate(rank=dense_rank(desc(Value))) %>%
    filter(rank<=10) %>%
    arrange(rank)

top_10_count

```
We can see that China is now the top emission producing country.

Let's make a plot of these top countries. We need to filter the data to just these top countries by using the `%in%` operator to only keep countries in our`Country` variable that are also in the `Country` variable within `top_10_count`. We can use the `pull()` function also of the `dplyr` package to specifically grab just the `Country` data out of `top_10_count`.


Since we have 10 countries we will want to differentiate them by color. 

To color our plot we will use the viridis color palette which is compatible with color-blindness by using the `scale_fill_viridis_d()` function which is simply available by loading the `ggplot2` package. There are a few variations such as discreet as `_d`, or binned continuous as `_b`, or continuous scale as `_c`. See [here](https://ggplot2.tidyverse.org/reference/scale_viridis.html) for more information.


```{r}

Top10b <- data_long %>%
  filter(Country %in% pull(top_10_count, Country)) %>%
  filter(Indicator == "Emissions") %>%
  filter(Year >= 1900) %>%
  ggplot(aes(x = Year, y = Value, color = Country)) +
  geom_line() +
  scale_color_viridis_d()+
  theme_linedraw() + 
  labs(title = "Top 10 Emissions-producing Countries in 2010 (1900-2014)",
       subtitle = "Ordered by Emissions Produced in 2014",
       y = "Emissions (Metric Tons)",
       x = "Year") +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16))

Top10b

```

It's still a bit difficult to tell which line corresponds to which country. So, let's add a label. One way to do this is to add text layer to our plot using the `geom_text()` function of the `ggplot2` package. We need to first specify what data we will use, in this case we will filter for just the data for the last year (which we can do using the `last()` function of the `dplyr` package) and then we need to indicate that our label will be based on the `Country` variable using the `aes()` aesthetics mapping argument. We will also get rid of our legend since we will not need it anymore, by using the `theme()` function of the `ggplot2` package.

```{r}

Top10b +
geom_text(data = data_long %>%
  filter(Country %in% pull(top_10_count, Country)) %>%
  filter(Indicator == "Emissions") %>%
  filter(Year == last(Year)), aes(label = Country)) +
  theme(legend.position = "none")
```

Not bad, but some of the labels are overlapping and difficult to read. We can use the `check_overlap = TRUE` argument within the `geom_text()` function to remove overlapping variables and we can expand the plot area horizontally so that the names are not cutoff by using `scale_x_continuous(expand = c(0.2,0))`.

```{r}

Top10b +
geom_text(data = data_long %>%
  filter(Country %in% pull(top_10_count, Country)) %>%
  filter(Indicator=="Emissions") %>%
  filter(Year == last(Year)), aes(label = Country), check_overlap = TRUE) + 
  scale_x_continuous(expand = c(0.2,0))+
  theme(legend.position = "none")

```

This is easier to read now, but it also causes us to lose some of the labels. 
There are several alternative ways we can keep all of our labels and make them easier to read. The first package we will show is called `directlabels`.

The most simple option is to use the `direct.label()` function. which will automatically add labels at the end of the lines. However, it is a bit difficult to see some of our labels as they get automatically sized to fit the plot.




```{r}

direct.label(Top10b) +scale_x_continuous(expand = c(0.3,0))
```

Alternatively this can be done in a more `ggplot2` layering method by using the `geom_dl()` function.

```{r}

Top10b +scale_x_continuous(expand = c(0.3,0)) +
     geom_dl(aes(label = Country), method = list("last.bumpup")) +
     theme(legend.position = "none")
```

This is nice and legible now. We have all 10 countries names listed and they are in order of the last data point and they are relatively close to the lines that they correspond to. 

Another option is to use a different method in the `directlables` package. [Here](http://directlabels.r-forge.r-project.org/docs/index.html){target="_blank"} is a list of options.

The `"angled.boxes"` method looks nice for some plots but doesn't work very well for our plot:
```{r}
direct.label(Top10b, method = list("angled.boxes"))+scale_x_continuous(expand = c(0.3,0)) 
```

However the `"last.polygons"` method works quite well:
```{r}
direct.label(Top10b,method = list("last.polygons"))+scale_x_continuous(expand = c(0.3,0))
```
The second package is the `ggrepel` package which is especially good for crowded labels that might overlap one another. It allows for more control than the `directlabels` package. We will use the `geom_text_repel()` function. Just like with `geom_text`, first we need to specify what data we want to include. We then specify with the `aes()` argument that our label will be based on the `Country` variable and we again specify what variable to use for our x axis and y axis, so that we indicate where the labels should be plotted. 

```{r}

Top10b + geom_text_repel(data = data_long %>%
  filter(Country %in% pull(top_10_count, Country)) %>%
  filter(Indicator=="Emissions") %>%
  filter(Year == last(Year)),
            aes(label = Country,
                x = Year,
                y = Value)) +
  theme(legend.position = "none")+scale_x_continuous(expand = c(0.3,0))

```
You can see that this package creates segments that connect the label to the line.

There are many arguments to use to style your labels just the way that you want:

```{r, echo = FALSE, out.width = "600 px"}
knitr::include_graphics(here::here("img", "ggrepel.png"))
```

See [here](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html){target="_blank"} for more details.


```{r}

Top10b + geom_text_repel(data = data_long %>%
  filter(Country %in% pull(top_10_count, Country)) %>%
  filter(Indicator=="Emissions") %>%
  filter(Year == last(Year)),
            aes(label = Country,
                x = Year,
                y = Value),
            nudge_x = 10,
              hjust = 1,
              vjust = 1,
       segment.size = 0.25,
              force = 1)+
  theme(legend.position = "none")+
  scale_x_continuous(expand = c(0.3,0))+
  scale_y_continuous(expand = c(0.3,0))

```
Nice, that looks pretty good.

Now let's try showing our data in a different way. This time we will create a `geom_tile` plot.
To color our plot we will use the viridis color palette again  but this time we will use the `scale_fill_viridis_c()`, recall that the `_c` indicates a continuous scale. See [here](https://ggplot2.tidyverse.org/reference/scale_viridis.html) for more information.  Again, we will filter our data to include only the Countries included in the `Country` variable of the `top_10_count`. Recall that the `pull()` function specifically  grabs the `Country` variable data values within `top_10_count`. Then we will use the `fct_reorder()` function of the `forcats` package to order our countries based on the last emission value in 2014. 

To use this function, the variable that is to be reordered is listed first, then the variable that is being used to determine the order, followed by a function to determine the order, in this case the last value using the `last()` function (recall that this is also a function of the `dplyr` package).

```{r}
Top10<-data_long %>%
  filter(Country %in% pull(top_10_count, Country)) %>%
  filter(Indicator=="Emissions") %>%
  filter(Year>=1900)%>%
  ggplot(aes(x=Year, y=fct_reorder(Country, Value, last))) +
  geom_tile( aes(fill=log(Value))) +
  scale_fill_viridis_c()+
  scale_x_continuous(breaks = seq(1900,2014,by=5),
                     labels = seq(1900,2014,by=5)) + 
  labs(title = "Top 10 "~CO[2]~"Emission-producing Countries in 2014",
    subtitle = "Ordered by Emissions Produced in 2014",
        fill = "Ln(CO2 Emissions (Metric Tons))") +
  theme_classic() +
  theme(axis.text.x = element_text(size = 12, angle = 90),
        axis.text.y = element_text(size = 12),
         axis.title = element_blank(),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
    legend.position = "bottom")

Top10

```

We can also create this plot directly without using the `top_10_count` tibble, by creating a new variable for the last value that we will call `last_val`, or in other words the emission value in 2014 for each country. To do this we need to first use the `group_by()` function of the `dplyr` package to make sure that the last value is calculated and repeated for each row for a given country. Here you can see that that is the case for Afghanistan.


```{r}

data_long %>%
  filter(Indicator=="Emissions") %>%
  filter(Year>=1900) %>%
  group_by(Country) %>%
  mutate(last_val = last(Value))
```

Now we will also create a `rank` variable like we did when we created `top_10_count` that will be calculated as the rank of the countries based on the `last_val` value (again this is the emission value in the last year of the data, 2014). Now we want to ungroup our data, as we want the rank to be calculated across the countries.     

```{r}

data_long %>%
  filter(Indicator=="Emissions") %>%
  filter(Year>=1900) %>%
  group_by(Country) %>%
  mutate(last_val = last(Value)) %>%
  ungroup() %>%
  mutate(rank=dense_rank(desc(last_val))) %>%
  filter(rank<=10) 

```

Now we can put it all together to create the plot directly from `data_long`.

```{r}

Top10<-data_long %>%
  filter(Indicator == "Emissions") %>%
  filter(Year >= 1900) %>%
  group_by(Country) %>%
  mutate(last_val = last(Value)) %>%
  ungroup() %>%
  mutate(rank=dense_rank(desc(last_val))) %>%
  filter(rank<=10) %>%
  ggplot(aes(x=Year, y=fct_reorder(Country, Value, last))) +
  geom_tile( aes(fill=log(Value))) +
  scale_fill_viridis_c() +
  scale_x_continuous(breaks = seq(1900,2014,by=5),
                     labels = seq(1900,2014,by=5)) + 
  labs(title = "Top 10 "~CO[2]~"Emission-producing Countries in 2014",
    subtitle = "Ordered by Emissions Produced in 2014",
        fill = "Ln(CO2 Emissions (Mg))") +
  theme_classic() +
  theme(axis.text.x = element_text(size = 12, angle = 90),
        axis.text.y = element_text(size = 12),
         axis.title = element_blank(),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
    legend.position = "bottom")

Top10
```
We can see that Germany had very low emission rates at the end of World War II. We see that the US has consistently had high emission rates since 1900, but that the emission rates in China recently surpassed that of the US. The portions of the plot that are white indicate that there is no emission data for that country.

Now let's take a look at the data in slightly different way. Let's look at overall global emissions by calculating a sum each year of all the emission values for the different countries. Note that this is limited to only the countries included in the dataset. 

To calculate this value we will first use the `group_by()` function of the `dplyr` package. This will allow our calculation to be performed on aggregated data by the different values for the `Year` variable. Otherwise, we would simply get a sum of overall emissions across all of the years in the data set.

Then we will use the `summarize()` function (also of the `dplyr` package) and the base `sum()` function to calculate a sum of the emission values each year.

Since we will be plotting only one value each year, we do not need to assign a `group` in the `aes()` argument. this time we will make the size of the line that will be plotted a bit larger using the `size()` argument in the `geom_line()` function.

```{r}
CO2_world<-data_long %>%
  filter(Indicator == "Emissions") %>%
  group_by(Year) %>%
  summarize(Value = sum(Value)) %>%
  ggplot(aes(x = Year, y = Value)) +
  geom_line(size = 1.5) + 
  labs(title = "World "~CO[2]~" Emissions per Year , 1751-2014",
     caption = "Limited to reporting countries", 
           y = "Emissions (Metric Tonnes)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16))
CO2_world

```

OK, we can now clearly see that global CO2 emissions have dramatically risen since 1900.

We can make an animation of this plot using the `gganimate` package.  We will use the `shadow_wake()` function to create our annimation and the `annimate()` function to show it. 

```{r, Animation_1, warning=FALSE}
animation_1 <- data_long %>%
  filter(Indicator == "Deaths") %>%
  ggplot(aes(x = Year, 
             y = Value, 
         group = Country, 
         color = Region, 
          size = Region, 
         alpha = Region)) +
  geom_point() +
  scale_color_manual(values = c("Red","Black")) +
  scale_alpha_manual(values = c(0.1, 1)) +
   scale_size_manual(values = c(0.25, 2)) +
  labs(title = "Distribution of Indicators by Year and Value, 1980-2010",
           y = "Crude Mortality Rate") +
  theme(axis.text.x = element_text(angle = 90)) + 
  theme_classic() +
  transition_time(as.integer(Year)) +
  gganimate::shadow_wake(wake_length = 1, alpha = FALSE)

gganimate::animate(animation_1, fps = 10, duration = 5)
```


## Yearly Growth in GDP per Capita (1801 to 2019)

Now we will take a look a GDP growth of various countries

```{r}
data_long %>%
  filter(Indicator == "GDP") %>%
  ggplot(aes(x = Year, y = Value, group = Country)) +
  geom_line(alpha = 0.2) + 
  labs(title = "Country GDP Growth per Capita per Year (Annual %), 1801-2019",
     caption = "Limited to reporting countries",
           y = "GDP Growth per Capita (Annual %)") +
  geom_line(data = data_long %>%
  filter(Indicator == "GDP",
           Country == "United States"), 
  aes(x=Year, y=Value, color = Country)) +
  scale_colour_manual(values=c("red")) +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       legend.title = element_blank())
```
We can see that the variation in GDP has become greater over time.

```{r}
data_long %>%
  filter(Indicator == "GDP",
         Year >= 1801) %>%
  group_by(Year) %>%
  summarise(Value = mean(Value, na.rm = TRUE)) %>%
  ggplot(aes(x=Year, y=Value)) +
  geom_line() + 
  labs(title = "Mean Country GDP Growth per Capita per Year (Annual %), 1801-2019",
     caption = "Limited to reporting countries", 
           y = "GDP Growth per Capita (Annual %)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16))
```

## Energy Use per Person (1960 to 2015)

```{r}
data_long %>%
  filter(Indicator == "Energy") %>%
ggplot(aes(x=Year, y= Value, group=Country)) +
  geom_line(alpha = 0.2) + 
  geom_line(data = data_long %>%
  filter(Indicator == "Energy",
           Country == "United States"), aes(x=Year, y=Value, color = Country)) +
  scale_colour_manual(values=c("red")) +
  labs(title = "Country Energy Use (kg of Oil Equivalent per Capita), 1960 to 2015",
     caption = "Limited to reporting countries", 
           y = "Energy Use (kg of Oil Equivalent per Capita)")+
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 15),
       legend.title = element_blank())
```

Let's see who the top countries are. First let's take a look at the year 2000, and then 2014.

```{r}

data_long %>%
filter(Indicator == "Energy") %>%
  filter(Year == 2000) %>%
 slice_max(Value, n = 10)


data_long %>%
filter(Indicator == "Energy") %>%
  filter(Year == 2014) %>%
  slice_max(Value, n = 10)

```


```{r}
data_long %>%
  filter(Indicator == "Energy") %>%
  group_by(Year) %>%
  summarise(Value = sum(Value, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, y = Value)) +
  geom_line() + 
  labs(title = "Worldwide Energy Use (kg of Oil Equivalent per Capita), 1960 to 2015",
     caption = "Limited to reporting countries",
           y = "Energy Use (kg of Oil Equivalent per Capita)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 15))
```

## Crude Mortality Rate

```{r}

Mortality <-data_long %>%
  filter(Indicator == "Deaths") %>%
  ggplot(aes(x = Year, y = Value, group = Country)) +
  geom_line(alpha = 0.2) + 
  geom_line(data = data_long %>%
  filter(Indicator == "Deaths",
           Country == "United States",
              Year >= 1960, 
              Year <= 2019), 
  aes(x = Year, y = Value, color = Country)) +
  scale_colour_manual(values=c("red")) +
  labs(title = "Country Crude Mortality Rate (per 1000 Persons), 1960 to 2019",
     caption = "Limited to reporting countries",
           y = "Crude Mortality Rate (per 1000 Persons)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       legend.title = element_blank())

Mortality

```

Let's take a look to see which countries account for the large peaks in Morality in the late 1970s and the early 1990s. It's always a good idea to check your data if you see anomalies like this. 

```{r}
data_long %>%
  filter(Indicator == "Deaths", Year == 1978) %>% 
  slice_max(Value, n = 3)
```

Looks like Cambodia is the country with the large peak in the late 1970s. If you look up the history of Cambodia during this time period, you will see that the peak we are seeing makes sense because Cambodia experienced [war](https://en.wikipedia.org/wiki/Cambodian_Civil_War){target="_blank"} and [genicide](https://en.wikipedia.org/wiki/Cambodian_genocide){target="_blank"} during this time. 

```{r}
data_long %>%
  filter(Indicator == "Deaths", Year == 1993) %>% 
  slice_max(Value, n = 3)
```
Rwanda is the country with the peak in the early 1990s. This also makes sense because Rwanda experienced a [civil war](https://en.wikipedia.org/wiki/Rwandan_Civil_War){target="_blank"} at this time. 

What about now? What countries have the highest rates?

```{r}
data_long %>%
   filter(Indicator == "Deaths", Year == 2017) %>% 
  slice_max(Value, n = 10)
```
It seems that many eastern European countries currently have the highest mortality rates, as well as [Lesotho](https://apps.who.int/iris/bitstream/handle/10665/136910/ccsbrief_lso_en.pdf;jsessionid=227D2B563F133AE2054046887D2D905D?sequence=1){target="_blank"}.

Let's make a plot of just these countries:
```{r}
Mortality <-data_long %>%
  filter(Indicator == "Deaths") %>%
  group_by(Country) %>%
  mutate(last_val = last(Value)) %>%
  ungroup() %>%
  mutate(rank = dense_rank(desc(last_val))) %>%
  filter(rank <= 5) %>%
  ggplot(aes(x = Year, y = Value, color = Country)) +
  geom_line() + 
  scale_color_viridis_d()+
  labs(title = "Country Crude Mortality Rate (per 1000 Persons), 1960 to 2019",
     caption = "Limited to reporting countries",
           y = "Crude Mortality Rate (per 1000 Persons)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       legend.title = element_blank())

direct.label(Mortality, method = list("angled.boxes"))



```
With the exception of Lesotho, we can see that the mortality rate appears to be steadily increasing in these countries. 

What countries have the lowest reported rates? We can simply alter our plot code to not use the descending value to rank mortality. 

```{r}
Mortality <-data_long %>%
  filter(Indicator == "Deaths") %>%
  group_by(Country) %>%
  mutate(last_val = last(Value)) %>%
  ungroup() %>%
  mutate(rank = dense_rank(last_val)) %>%
  filter(rank <= 5) %>%
  ggplot(aes(x = Year, y = Value, color = Country)) +
  geom_line() + 
  scale_color_viridis_d()+
  labs(title = "Country Crude Mortality Rate (per 1000 Persons), 1960 to 2019",
     caption = "Limited to reporting countries",
           y = "Crude Mortality Rate (per 1000 Persons)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       legend.title = element_blank())

direct.label(Mortality, method = list("angled.boxes")) + 
  scale_x_continuous(expand = c(0.3,0))



```
Looks like many countries in the Persian Gulf region have the lowest rates of mortality. 

Let's make a plot of some of the countries that showed unusual patterns over time. We will include the US for comparison.

```{r}

data_long %>%
  filter(Indicator == "Deaths",
            Country %in% c("United States", 
                           "Rwanda", 
                           "Cambodia", 
                           "Qatar", 
                           "Bulgaria"))%>%
  ggplot(aes(x = Year, y = Value, color = Country)) +
  geom_line() + 
  labs(title = " Crude Mortality Rate (per 1000 Persons), 1960 to 2019",
     caption = "Limited to reporting countries",
           y = "Crude Mortality Rate (per 1000 Persons)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16))
```

We can make a similar plot where each country is shown side by side by using the `facet_grid()` function of the `ggplot2` package. We need to indicate what variable we would like to use to group the data by and indicate it with this symbol `~`. If we include a period (to indicate all other variables) we can change the orientation of the plots:

1) `.~variable` plots the subplots horizontally (plot the facet variable like the x axis)
2) `variable ~.` plots the subplots vertically  (plot the facet variable like the y axis)

```{r}

data_long %>%
  filter(Indicator == "Deaths",
            Country %in% c("United States", 
                           "Rwanda", 
                           "Cambodia", 
                           "Qatar", 
                           "Bulgaria"))%>%
  ggplot(aes(x = Year, y = Value)) +
  geom_line() + 
  facet_grid(.~ Country)+
  labs(title = " Crude Mortality Rate (per 1000 Persons), 1960 to 2019",
     caption = "Limited to reporting countries",
           y = "Crude Mortality Rate (per 1000 Persons)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16))
```

We can see that recently the US has actually had higher mortality rates than Rwanda and Cambodia.

Let's see how the US ranks.

```{r}
data_long %>%
  filter(Indicator == "Deaths") %>%
       filter(Year == 2014) %>%
  group_by(Country) %>%
  mutate(last_val = last(Value)) %>%
  ungroup() %>%
  mutate(rank = dense_rank(desc(last_val)))%>%
  filter(Country == "United States")

```

The US ranked 68 out of 212 countries in 2014. This means that roughly 70% of the countries included had lower mortality rates than the US. See [here](https://www.healthsystemtracker.org/chart-collection/mortality-rates-u-s-compare-countries/#item-overall-age-adjusted-mortality-rate-decline-1980-2015){target="_blank"} and [here](https://www.drugabuse.gov/drug-topics/trends-statistics/overdose-death-rates){target="_blank"} for more information about mortality rates in the US. 

#### {.question_block}
Question Opportunity
How would you determine the total number of countries reporting in 2014?
####

Let's see what the overall trend in mortality has been over time.
```{r}

data_long %>%
  filter(Indicator == "Deaths") %>%
   group_by(Year) %>%
  summarise(Value = mean(Value, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, y = Value)) +
  geom_line(size = 1.4) + 
  labs(title = "Mean Country Crude Mortality Rate (per 1000 Persons), 1960 to 2018",
     caption = "Limited to reporting countries",
           y = "Crude Mortality Rate (per 1000 Persons)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16))
  
```
We can see that despite some countries with different patterns of mortality, overall the world has experienced much lower rates of mortality than in previous decades.

## US Disasters

Now let's take a look at the disaster data for the US.

```{r}

data_long %>%
  filter(Indicator == "Disasters") %>%
  ggplot(aes(x = Year, y = Value, group = Country)) +
  geom_line() + 
  labs(title = "US Disasters, 1980 to 2019",
    subtitle = "Droughts, Floods, Freezes, Severe Storms. Tropical Cyclones, Wildfires, and Winter Storms", 
           y = "Disaster Count") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
         plot.title = element_text(size = 16))
  
```
 
 In general, it appears that temperatures have increased over time. We can add another `ggplot2` layer by using the `geom_smooth()` to add a trend line. There are several methods to do this. We will use the `loess` method which stands for: [Locally Weighted Smoothing](https://www.statisticshowto.com/lowess-smoothing){target="_blank"}. This method fits a trend to the data but does not assume that the trend will fit a particular shape.
 
```{r}

data_long %>%
  filter(Indicator == "Disasters") %>%
  ggplot(aes(x = Year, y = Value, group = Country)) +
  geom_line() + 
  geom_smooth(method = "loess") +
  labs(title = "US Disasters, 1980 to 2019",
    subtitle = "Droughts, Floods, Freezes, Severe Storms. Tropical Cyclones, Wildfires, and Winter Storms", 
           y = "Disaster Count") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
         plot.title = element_text(size = 16))
  
```

We can see that the rate of disasters appears to be increasing over time. The added geom_smooth layer has added a blue trend line with the gray indicating the confidence interval of the trend line. 

But what is a confidence interval?

A confidence interval gives an estimated range of values which is likely to include the true values of the entire population (for example all women in the US) if we are using just a small sample (for example 200 women in the US that take a survey) of the entire population. See [here](https://mathbitsnotebook.com/Algebra1/StatisticsData/STPopSample.html){target="_blank"} for more explanation about samples and populations.

Thus the gray area shows other possible trend lines that may fit the data of the actual population. 

```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics('https://i1.wp.com/www.real-statistics.com/wp-content/uploads/2012/12/confidence-prediction-interval.png?w=860')
```
####[source](http://www.real-statistics.com/regression/confidence-and-prediction-intervals/){target="_blank"}

We could think of our data as the entire population. We have the actual counts for the number of disasters (based on specific definitions of disasters) that occurred in the US each year from 1980 to 2010. Therefore, we would not need to calculate confidence intervals so we can remove them from our plot by using the `se = FALSE` argument of the `geom_smooth()` function of `ggplot2`. Confidence intervals are plotted by default as data is more often from a small sample of true populations and we  try to generalize our trends based our sample to the true population.


```{r}

data_long %>%
  filter(Indicator == "Disasters") %>%
  ggplot(aes(x = Year, y = Value, group = Country)) +
  geom_line() + 
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "US Disasters, 1980 to 2019",
    subtitle = "Droughts, Floods, Freezes, Severe Storms. Tropical Cyclones, Wildfires, and Winter Storms", 
           y = "Disaster Count") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
         plot.title = element_text(size = 16))
```


## US Temperature

How about national average temperatures in the US?

```{r}

data_long %>%
  filter(Indicator == "Temperature") %>%
  ggplot(aes(x = Year, y = Value, group = Country)) +
  geom_line() + 
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "US Average Annual Temperature, 1895 to 2019",
           y =  "Temperature (Fahrenheit)") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
         plot.title = element_text(size = 16))

```
Temperatures also appear to be rising, especially in the last 10-20 years.





# **Data Visualization**
*** 

Now Let's try putting some of the different data types together together. We have previously used `facet_grid()` to plot multiple subplots simultaneously. Now we will use the `facet_wrap()` function of the `ggplot2` package, which also plots multiple subplots simultaneously, however it also allows for different scales for the y-axis of the subplots. This is preferable in this case because it is difficult to see the data if all the subplots were plotted with the same y-axis scale, as you can see here: 


```{r,fig.width=10, fig.height=10}
ggplot(data_long, aes(x = Year, y = Value, group = Country)) +
  geom_line(alpha = 0.2) + 
  geom_line(data = data_long %>%
  filter(Country == "United States"), 
  aes(x = Year, y = Value, color = Country)) +
  scale_colour_manual(values = c("red")) +
  facet_grid(~Indicator,
             scales = "free_y")+
             #ncol = 1) +
  labs(title = "Distribution of Indicators by Year and Value", 
           y = "Indicator Value") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       strip.text = element_text(size = 16, face = "bold"))
```

To use `facet_wrap()` with the option for a different y-axis scale for each subplot, we need to set the `scales` argument equal to `"free_y"`. We can also indicate where we would like the label for the subplots to be located by using the `strip.position` argument. Notice that we can change the size or style of the font for these labels using the `strip.text =` argument of the `theme()` function. We can also specify how many rows or columns we would like the subplots to be shown. 


```{r,fig.width=10, fig.height=10}
ggplot(data_long, aes(x = Year, y = Value, group = Country)) +
  geom_line(alpha = 0.2) + 
  geom_line(data = data_long %>%
  filter(Country == "United States"), 
  aes(x = Year, y = Value, color = Country)) +
  scale_colour_manual(values = c("red")) +
  facet_wrap(Indicator~.,
             scales = "free_y",
             strip.position = "right",
             ncol = 1) +
  labs(title = "Distribution of Indicators by Year and Value", 
           y = "Indicator Value") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       strip.text = element_text(size = 16, face = "bold"))
```

Here we will facet by two variables: `Indicator` and `Region` (which is if the data is from the US or other countries). First we will filter out the data about disasters and temperature as this is only for the US, by using the `filter()` function and `!=` which indicates "not equal to". In this case we want to use `facet_grid()` instead of `facet_wrap()` so that the same y-axis will be used across the rows.

```{r,fig.width=10, fig.height=10}
data_long %>%
  filter(Indicator != "Disasters" ,
         Indicator != "Temperature")  %>%
ggplot( aes(x = Year, y = Value, group = Country)) +
  geom_line() + 
  facet_grid(Indicator ~ Region,
             scales = "free_y")+
  labs(title = "Distribution of Indicators by Year and Value", 
           y = "Indicator Value") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       strip.text = element_text(size = 16, face = "bold"))
```

We can also use  `scales = "free"` with `facet_wrap()` to have a different axis for each plot.
```{r,fig.width=10, fig.height=10}
data_long %>%
  filter(Indicator != "Disasters" ,
         Indicator != "Temperature")  %>%
ggplot( aes(x = Year, y = Value, group = Country)) +
  geom_line() + 
  facet_wrap(Indicator ~ Region,
             scales = "free", 
               ncol = 2)+
  labs(title = "Distribution of Indicators by Year and Value", 
           y = "Indicator Value") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       strip.text = element_text(size = 16, face = "bold"))
```


From these plots we can see that each type of data spans a different time span.

## Time spans of data

Let's take a look at the reporting countries for each year for each type of data for the global indicators. To calculate the number of reporting countries we will use the `tally()` function of the `dplyr` package to get the count for each year and indicator. Thus we will first group by  year and the `Label` variable (as a proxy for the `Indicator` variable), as this also specifies the different indicators but with additional information and formatting so that we can have nice labels in our plot.

We can add also vertical lines to our plot using the `geom_vline()` function  of the `ggplot2` package.

```{r}
data_long %>%
   filter(Indicator != "Disasters" &
          Indicator != "Temperature") %>%
  group_by(Year, Label, .drop=FALSE) %>%
  tally() %>%
  ggplot(aes(x = Year, y = n, color = Label)) +
  geom_line() +
  geom_vline(xintercept = 1980, linetype = 2, color = "black") +
  geom_vline(xintercept = 2014, linetype = 2, color = "black") +
  labs(title = "Countries with Complete Data per Year",
    subtitle = "Global Data", 
           y = "Countries") + 
  scale_x_continuous(breaks = seq(1750,2020,by=10),
                     labels = seq(1750,2020,by=10)) +
  theme(axis.text.x = element_text(angle = 90),
       axis.title.x = element_blank(),
    legend.position = "bottom") +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12, angle = 90),
        axis.text.y = element_text(size = 12),
       axis.title.x = element_text(size = 12),
       axis.title.y = element_text(size = 12),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16),
       legend.title = element_blank())
```

We can see that all of our data spans from 1980 to 2014.

What about the US data?
We can summarize the data based on the minimum and maximum `Year` value using the `summarize()` function. Recall that this is a function of the `dplyr` package.

```{r}
data_long %>%
  filter(Country == "United States") %>%
  group_by(Label) %>%
  summarize(First_year= min(Year), Last_year = max(Year))

```
Now we will plot a segment line for the span using `geom_segment()` and points for the first years and last years using `geom_point()`. This time we will add horizontal lines using `geom_hline()` to show where the time spans overlap.

```{r}
data_long %>%
  filter(Country == "United States") %>%
  group_by(Label) %>%
  summarize(First_year = min(Year), Last_year = max(Year)) %>%
  ggplot(aes(y = Label, x = Last_year)) +
  geom_segment(aes(y = Label,
                yend = Label,
                xend = Last_year,
                   x = First_year )) +
  geom_point(aes(y = Label, x = First_year)) +
  geom_point(aes(y = Label, x = Last_year)) + 
  geom_vline(xintercept = 1980, linetype=2) +
  geom_vline(xintercept = 2014, linetype=2) +
  labs(title = "Complete Data per Year",
    subtitle = "US-specific Data", 
           y = "Countries") + 
  scale_x_continuous(breaks = seq(1750,2020,by=10),
                      labels = seq(1750,2020,by=10)) +
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 12,angle = 90),
        axis.text.y = element_text(size = 12),
         axis.title = element_blank(),
       plot.caption = element_text(size = 12),
         plot.title = element_text(size = 16))
```
It looks like the overlapping time spans for the different datasets is from 1980 to 2014.



```{r, Animation_2, warning=FALSE, eval=FALSE}
animation_2 <- data_long %>%
  filter(Indicator=="Energy") %>%
  ggplot(aes(x = Year, 
             y = Value, 
         group = Country, 
         color = Region, 
          size = Region, 
         alpha = Region)) +
  geom_point() +
  scale_color_manual(values = c("Red","Black")) +
  scale_alpha_manual(values = c(0.5, 1)) +
   scale_size_manual(values = c(0.25, 2)) +
  labs(title="Distribution of Indicators by Year and Value, 1980-2010",
       y = "Energy Use per Capita") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) + 
  
  transition_time(as.integer(Year)) +
  shadow_wake(wake_length = 1, alpha = FALSE)

animate(animation_2, fps = 10, duration = 5)

```


```{r, Animation_3, warning=FALSE, eval=FALSE}
animation_3 <- data_long %>%
  #filter(Type=="Global") %>%
  filter(Indicator=="GDP") %>%
  #filter(Year>=1980) %>%
  #filter(Year<=2010) %>%
  ggplot(aes(x = Year, 
             y = Value, 
         group = Country, 
         color = Region, 
          size = Region, 
         alpha = Region)) +
  geom_point() +
  scale_color_manual(values = c("Red","Black")) +
  scale_alpha_manual(values = c(0.1, 1)) +
   scale_size_manual(values = c(0.25, 2)) +
  labs(title="Distribution of Indicators by Year and Value, 1980-2010",
       y= "GDP Growth per Capita (%)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  
  transition_time(as.integer(Year)) +
  shadow_wake(wake_length = 1, alpha = FALSE)

animate(animation_3, fps = 10, duration = 5)
```

```{r, Animation_4, warning=FALSE, eval=FALSE}
animation_4 <- data_long %>%
  #filter(Type=="Global") %>%
  filter(Indicator=="Emissions") %>%
  #filter(Year>=1980) %>%
  #filter(Year<=2010) %>%
  ggplot(aes(x = Year,
             y = Value, 
         group = Country, 
         color = Region, 
          size = Region, 
         alpha = Region)) +
  geom_point() +
  scale_color_manual(values = c("Red","Black")) +
  scale_alpha_manual(values = c(0.1, 1)) +
   scale_size_manual(values = c(0.25, 2)) +
  labs(title = "Distribution of Indicators by Year and Value, 1980-2010",
           y = "CO2 Emissions (Mg)") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) +
  transition_time(as.integer(Year)) +
  shadow_wake(wake_length = 1, alpha = FALSE)

animate(animation_4, fps = 10, duration = 5)
```




## US-specific


Let's plot all of the US indicators together.

```{r}


US_Indicators <- data_long %>%
  filter(Country=="United States")%>%
  filter(Year>=1980) %>%
  ggplot(aes(x=Year, y=Value)) + 
  geom_line() + 
  geom_smooth(method = "loess", se = FALSE) +
  facet_wrap(Label~., ncol=2, nrow=3, scales = "free_y") + 
  theme_linedraw() + 
  theme(axis.text.x = element_text(angle = 90, size = 12),
        axis.text.y = element_text(size = 12),
        strip.text.x = element_text(face = "bold", size = 12),
        axis.title.y = element_blank(),
        axis.title.x = element_text(size = 12)) + 
  labs(title = "US-specific Indicators")
US_Indicators
```

We can also plot the data with points for the individual values rather than a line using `geom_point()`.


```{r}
US_Indicators_point <- data_long %>%
  filter(Country=="United States")%>%
  filter(Year>=1980) %>%
  ggplot(aes(x=Year, y=Value)) + 
  geom_point() + 
  geom_smooth(method = "loess", se = FALSE) +
  facet_wrap(Label~., ncol=2, nrow=3, scales = "free_y") + 
  theme_linedraw() + 
  theme(axis.text.x = element_text(angle = 90, size = 12),
        axis.text.y = element_text(size = 12),
        strip.text.x = element_text(face = "bold", size = 12),
        axis.title.y = element_blank(),
        axis.title.x = element_text(size = 12)) + 
  labs(title = "US-specific Indicators")
US_Indicators_point

```

If we want to really look at how two indicators may relate to each other, it is important that both datasets span the same amount of time. Therefore, we will limit this plot to only the years where the data overlaps for both CO2 emissions and temperature.

```{r}
data_long %>%
  filter(Country == "United States") %>%
  filter(Year>=1980) %>%
  filter(Year<=2010) %>%
  filter(Indicator == "Emissions"|
         Indicator == "Temperature") %>%
  ggplot(aes(x=Year, y=Value)) +
  geom_line() +
  geom_smooth(method = "loess", se = FALSE) +
  scale_x_continuous(breaks = seq(1980,2010,by=5),
                     labels = seq(1980,2010,by=5)) + 
  facet_wrap(Indicator~., scales = "free_y", ncol=1) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90),
        axis.title = element_blank()) + 
  labs(title="US Emissions and Temperatures (1980-2010)")
```

We can see that there are very similar patterns of CO2 emission levels an average annual temperatures.
We will analyze this further in a bit. There are also some other common visualization techniques that utilize the mean of a set of values over a time span to show how values are changing over time in a different way.


To create such a visualization, we will first calculate the mean of our Emission and temperature values from 1980 to 2010 and create a new variable called `Mean`. Then we will calculate the difference of each value from the mean and create a new variable for these values called `Diff_from_mean`. Finally we will also create a factor variable about the sign of the `Diff_from_mean` value to distinguish positive or negative changes. We will use this to color our plots.

```{r}
data_long_us <- data_long %>%
  filter(Country == "United States") %>%
  filter(Year >= 1980,
         Year <= 2010) %>%
  group_by(Indicator) %>%
  mutate(Mean = mean(Value),
      Diff_from_mean= Value-Mean) %>%
  ungroup() %>%
  mutate(Diff_color = sign(Diff_from_mean)) %>%
  mutate(Diff_color = as.factor(Diff_color))


```


```{r}
glimpse(data_long_us)
```



OK, now we will create a plot that shows a bar for the change in each indicator from the mean value across the time span for each year.

```{r, fig.width=6, fig.height=6}
data_long_us %>%
  filter(Indicator == "Emissions"|
         Indicator == "Temperature"|
         Indicator == "Disasters") %>%
  ggplot(aes(x=Year, y=Value)) +
  geom_segment(aes(x=Year, y=Value, xend=Year, yend=Mean, color=Diff_color), size=3.25) +
  scale_color_manual(values = c("blue","red")) + 
  geom_hline(aes(yintercept=Mean), linetype=1, color="black") +
  facet_wrap(Indicator~., scales = "free_y", ncol=1) + 
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90),
         axis.title = element_blank(),
    legend.position = "none")  +
  labs(title = "US Disasters, Emissions, and Temperatures (1990-2010)",
    subtitle = "Indicator Mean of 1990-2010 Represented by Solid Black Line")
```
We can see from this plot that overall there has been an increase in Disasters, Emissions and Temperature in the most recent years. 

What if we look at mortality, gdp, and disasters in the same way?

```{r}
data_long_us %>%
  filter(Indicator=="Deaths"|
         Indicator=="GDP"|
           Indicator =="Disasters") %>%
  ggplot(aes(x=Year, y=Value)) +
  geom_segment(aes(x=Year, y=Value, xend=Year, yend=Mean, color=Diff_color), size=3.25) +
  scale_color_manual(values = c("blue","red")) + 
  geom_hline(aes(yintercept=Mean), linetype=1, color="black") +
  facet_wrap(Indicator~., scales = "free_y", ncol=1) + 
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90),
         axis.title = element_blank(),
    legend.position = "none")  +
  labs(title = "US Emissions and Temperatures (1990-2010)",
    subtitle = "Indicator Mean of 1990-2010 Represented by Solid Black Line")

```
Luckily at this point despite increased disaster rates, mortality appears to be decreasing. The GDP has been relatively consistent.

Now how about energy use and emissions?

```{r}
data_long_us %>%
  filter(Indicator=="Emissions"|
      Indicator == "Energy") %>%
  ggplot(aes(x=Year, y=Value)) +
  geom_segment(aes(x=Year, y=Value, xend=Year, yend=Mean, color=Diff_color), size=3.25) +
  scale_color_manual(values = c("blue","red")) + 
  geom_hline(aes(yintercept=Mean), linetype=1, color="black") +
  facet_wrap(Indicator~., scales = "free_y", ncol=1) + 
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90),
         axis.title = element_blank(),
    legend.position = "none")  +
  labs(title = "US Emissions and Energy Use (1990-2010)",
    subtitle = "Indicator Mean of 1990-2010 Represented by Solid Black Line")

```

Looks like in very recent years, there has been a decline in both energy use and CO2 emissions.




# **Data Analysis**
***


We see that CO2 emission levels, annual average national temperatures, and disasters counts appear to be increasing over time, but how can we assess this statistically?


### Correlation

We can use [correlation](https://www.mathsisfun.com/data/correlation.html){target="_blank"}. Correlation is a measure of strength the of a relationship between two variables. Often when we describe correlation we are referring to linear correlation and therefore the linear relationship between variables.

If we plot one variable on the x-axis and the other variable on the y-axis, we can see:

1) the strength of the relationship - based on how well the points form a line  
2) the direction of the relationship - based on if the points progress upward or downward 


If the variables point upward in a very clear line, then there is a strong positive relationship. If the points do not really form a line, then there is a weak linear relationship or no linear relationship - there may however be a nonlinear relationship if the points create a different but defined shape. See [here](https://towardsdatascience.com/estimating-non-linear-correlation-in-r-62c6571cb1db){target="_blank"} for more information. If the points form a downward sloping line, then there is a negative relationship.


```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics('https://www.mathsisfun.com/data/images/correlation-examples.svg')
```

#### [source](https://www.mathsisfun.com/data/correlation.html){target="_blank"}


The numbers bellow each plot above are called correlation coefficients. They range from -1 to 1. A value of zero indicates that there is no correlation between the variables. While a value of 1 or -1 indicates perfect correlation, the closer the coefficient is to 1 or -1, the stronger the relationship. The sign of the coefficient indicates the direction of the relationship. If there is a negative relationship then the variables show opposing changes from each other - as one gets larger the other gets smaller. If the sign is positive, then the variables increase similarly. 

Let's take a look at our data now. We have already plotted our US indicators across time, but we did not look at the linear trend. We will do that now using geom_point() to plot the individual data points and this time we will use the `"lm"` method which stands for linear method for our `geom_smooth()` layer. 

```{r}
US_Indicators_lm <- data_long %>%
  filter(Country=="United States")%>%
  filter(Year>=1980) %>%
  ggplot(aes(x=Year, y=Value)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(Label~., ncol=2, nrow=3, scales = "free_y") + 
  theme_linedraw() + 
  theme(axis.text.x = element_text(angle = 90, size = 12),
        axis.text.y = element_text(size = 12),
        strip.text.x = element_text(face = "bold", size = 12),
        axis.title.y = element_blank(),
        axis.title.x = element_text(size = 12)) + 
  labs(title = "US-specific Indicators")
US_Indicators_lm
```

First let's create a wide tibble for our US data so that we can similarly plot our data. To do this we will create a wide tibble using the `pivot_wider()` function of the `dplyr` package. This function requires values for two arguments, `names_from` and `values_from`. The variable that has the identity or labels for the values that you wish to create multiple new variables names from is used for the `names_from` argument. The variable that contains the corresponding values for the new variables is used for the `values_from` argument.

```{r}

wide_US <-data_long %>%
  filter(Country == "United States") %>%
  filter(Year>=1980) %>%
  filter(Year<=2010) %>%
  select(-Label) %>%
  pivot_wider(names_from = Indicator, values_from = Value)

```


```{r}
wide_US %>%
glimpse()
```

We can use the `cor.test()` of the `stats` package to calculate Pearson's correlation estimates, as well as confidence intervals for correlation estimates. This function allows for a few different methods to calculate correlation estimates. The default is the [Pearson's product-moment method](http://onlinestatbook.com/2/describing_bivariate_data/pearson.html){target="_blank"}. All three methods result in a correlation coefficient that ranges from -1 to 1 that indicate the strength of the association or relationship between the variables. However, each method has a slightly different calculation.

See [here](https://www.statisticshowto.com/probability-and-statistics/correlation-coefficient-formula/){target="_blank"} and [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3576830/){target="_blank"} for more information.


In the case of our data, individual points would be the measurements for each variable at each year.

```{r}
cor(pull(wide_US, Temperature), pull(wide_US, Year))
cor(pull(wide_US, Emissions), pull(wide_US, Year))
cor(pull(wide_US, Disasters),pull(wide_US, Year))
```

We can see that in all cases, there appears to be a positive linear relationship between the tested US indicators and time. We see the relationship is positive because the correlation estimates are positive (as well as the fact that our plots show upward linear relationships). 


We can assess the strength of the relationship based on this table which provides general guidelines:

```{r}
knitr::include_graphics(here("img", "guides.png"))
```
We also see that the correlation of temperature with time is low, it is very strong for the emissions data, and moderate for the disaster data.

### Linear Regression

We can also use a [linear regression](http://sites.utexas.edu/sos/guided/inferential/numeric/bivariate/cor/#:~:text=A%20correlation%20analysis%20provides%20information,variable%20based%20on%20the%20other.){target="_blank"} to evaluate the relationship between our variables. This helps us to answer slightly deeper questions like:  

Do changes in time predict or explain changes in temperature, emission, or disaster values?  

We can get the results from a linear model by using the base `summary()` function and the `lm()` function of the `stats` package. 

The variable on the left of the `~` indicates what we are trying to predict also known as the dependent variable, while the variable(s) on the right are independent.

```{r}
summary(lm(data = wide_US, Temperature ~ Year))
summary(lm(data = wide_US, Emissions ~ Year))
summary(lm(data = wide_US, Disasters ~ Year))
```
In all cases, yes it appears that all of these indicators show a positive association (due to positive t value) with time - meaning they show an increase over time.

Notice that the `Multiple R-squared` value in the output is equal to the correlation coefficient squared! 

Since CO2 emission levels an average annual temperatures appear to have similar patterns over time, we might want to analyze if these values are correlated with one another.

We might also ask:

Are emission levels associated with temperature levels or disaster levels? Can we predict or explain temperature or disaster levels based on emission levels?

Let's first plot both on the same plot, where emissions will be plotted on one axis and temperatures on the other.


```{r}
wide_US %>%
  ggplot(aes(x=Emissions, y=Temperature)) +
  geom_line() +
  geom_smooth(method = "lm", se = FALSE) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90),
        axis.title = element_blank()) + 
  labs(title="US Emissions and Temperature (1980-2010)")
```

```{r}
wide_US %>%
  ggplot(aes(x=Temperature, y=Disasters)) +
  geom_line() +
  geom_smooth(method = "lm", se = FALSE) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90),
        axis.title = element_blank()) + 
  labs(title="US Disasters and Temperatures (1980-2010)")
```


```{r}
wide_US %>%
  ggplot(aes(x=Emissions, y=Disasters)) +
  geom_line() +
  geom_smooth(method = "lm", se = FALSE) +
   
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90),
        axis.title = element_blank()) + 
  labs(title="US Emissions and Disasters (1980-2010)")
```


Now we can calculate  Pearson correlation coefficients. 

```{r}
  
cor(pull(wide_US, Emissions),
    pull(wide_US, Temperature))

cor(pull(wide_US, Temperature),
    pull(wide_US, Disasters))

cor(pull(wide_US, Emissions),
    pull(wide_US, Disasters))

```



And finally perform linear regression analysis:



```{r}
summary(lm(data = wide_US, Temperature ~ Emissions))
summary(lm(data = wide_US, Disasters ~ Temperature))
summary(lm(data = wide_US, Disasters ~ Emissions))
```

Both temperature and the number of disasters per year appear to increase with increased CO2 emissions, as the p value is less than 0.05 in both regressions. However, the multiple R-squared value, and Pearson's correlation coefficients were moderate for both relationships. Suggesting that the relationship is not very strong and that there are likely other factors that influence temperature and disasters besides C02 emissions. This makes sense with what we know about the earth's atmosphere. There are other greenhouse gases that contribute to warming temperatures, and the existing CO2 already in the atmosphere also traps heat and greatly impacts the temperature. Furthermore we are looking at US emissions and how they influence US temperatures, but there are also CO2 emissions produced by other countries. There are other aspects that influence disaster rate as well, such the rate of humidity levels and rainfall for fires. 

While the analyses that we performed give us some indication of how these different datasets relate to one another, one would realistically want to perform a mixed effects model or growth curve analysis to account for the fact that these data are paired across time points and may vary differently with time and to include these other factors that we just discussed. ... AVOCADO needs links etc.  feel free to help this section.





Now we will create a plot that summarizes our major findings. We will use the `plot_layout()` function of the `patchwork` package.

```{r, out.width= "9000px", "out.height= 7000px"}
(CO2_world | Top10)/ US_Indicators
(CO2_world | Top10)/ US_Indicators +
  plot_layout(widths = c(1, 2), heights = unit(c(4, 5), c('cm', 'null')))

png(here::here("img", "mainplot.png"), width = 900, height = 700)
(CO2_world | Top10)/ US_Indicators +
    plot_layout(widths = c(1, 2), heights = unit(c(4, 5), c('cm', 'null')))
dev.off()
```


## **Homework**

***

Ask students to create a plot with labels showing the countries with the lowest CO2 emission levels.

Ask students to plot energy use and emissions on a scatter plot, calculate the Pearson's correlation coefficient, and discuss what the results mean. 

## **Summary**

Even though  there is quite a bit of scientific evidence to indicate that in fact CO2 emissions trap heat and lead to increased global temperatures, it is important to realize that there are other factors involved in the relationship between US CO2 emissions and US annual average temperatures. However, it is vital that we work around the globe to reduce greenhouse gas emissions to mitigate the increased temperatures that we will experience due to the existing CO2 already in the atmosphere so that the warming temperatures aren't as extreme as they could be. Furthermore, we need to prepare for increased rates of natural disasters and how these may influence people around the world. Evidence suggests that impoverished people are the [most affected by diasters](https://ourworldindata.org/natural-disasters){target="_blank"}. We need to be particularly mindful of this as we prepare.  

## **Helpful Links**


confidence intervals linear reg.
https://rstudio-pubs-static.s3.amazonaws.com/195401_20b3272a8bb04615ae7ee4c81d18ffb5.html
